// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type GeoRestrictionsInitParameters struct {

	// (String)
	Label *string `json:"label,omitempty" tf:"label,omitempty"`
}

type GeoRestrictionsObservation struct {

	// (String)
	Label *string `json:"label,omitempty" tf:"label,omitempty"`
}

type GeoRestrictionsParameters struct {

	// (String)
	// +kubebuilder:validation:Optional
	Label *string `json:"label,omitempty" tf:"label,omitempty"`
}

type KeylessServerInitParameters struct {

	// (Attributes) Configuration for using Keyless SSL through a Cloudflare Tunnel (see below for nested schema)
	Tunnel *TunnelInitParameters `json:"tunnel,omitempty" tf:"tunnel,omitempty"`
}

type KeylessServerObservation struct {

	// (String) When the Keyless SSL was created.
	// When the Keyless SSL was created.
	CreatedOn *string `json:"createdOn,omitempty" tf:"created_on,omitempty"`

	// (Boolean) Whether or not the Keyless SSL is on or off.
	// Whether or not the Keyless SSL is on or off.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (String) The keyless SSL name.
	// The keyless SSL name.
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// (String) Identifier
	// Keyless certificate identifier tag.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (String) When the certificate was last modified.
	// When the Keyless SSL was last modified.
	ModifiedOn *string `json:"modifiedOn,omitempty" tf:"modified_on,omitempty"`

	// (String) The keyless SSL name.
	// The keyless SSL name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (List of String) Available permissions for the Keyless SSL for the current user requesting the item.
	// Available permissions for the Keyless SSL for the current user requesting the item.
	Permissions []*string `json:"permissions,omitempty" tf:"permissions,omitempty"`

	// (Number) The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
	// The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// (String) Status of the zone's custom SSL.
	// Status of the Keyless SSL.
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	// (Attributes) Configuration for using Keyless SSL through a Cloudflare Tunnel (see below for nested schema)
	Tunnel *TunnelObservation `json:"tunnel,omitempty" tf:"tunnel,omitempty"`
}

type KeylessServerParameters struct {

	// (Attributes) Configuration for using Keyless SSL through a Cloudflare Tunnel (see below for nested schema)
	// +kubebuilder:validation:Optional
	Tunnel *TunnelParameters `json:"tunnel,omitempty" tf:"tunnel,omitempty"`
}

type SSLInitParameters_2 struct {

	// (String) A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
	// A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
	BundleMethod *string `json:"bundleMethod,omitempty" tf:"bundle_method,omitempty"`

	// (String) The zone's SSL certificate or certificate and the intermediate(s).
	// The zone's SSL certificate or certificate and the intermediate(s).
	Certificate *string `json:"certificate,omitempty" tf:"certificate,omitempty"`

	// (Attributes) Specify the region where your private key can be held locally for optimal TLS performance. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Options allow distribution to only to U.S. data centers, only to E.U. data centers, or only to highest security data centers. Default distribution is to all Cloudflare datacenters, for optimal performance. (see below for nested schema)
	GeoRestrictions *GeoRestrictionsInitParameters `json:"geoRestrictions,omitempty" tf:"geo_restrictions,omitempty"`

	// (Attributes) (see below for nested schema)
	KeylessServer *KeylessServerInitParameters `json:"keylessServer,omitempty" tf:"keyless_server,omitempty"`

	// 1_alpha-2#Officially_assigned_code_elements) can be chosen, such as 'country: IN', as well as 'region: EU' which refers to the EU region. If there are too few data centers satisfying the policy, it will be rejected.
	// Specify the policy that determines the region where your private key will be held locally. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Any combination of countries, specified by their two letter country code (https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements) can be chosen, such as 'country: IN', as well as 'region: EU' which refers to the EU region. If there are too few data centers satisfying the policy, it will be rejected.
	Policy *string `json:"policy,omitempty" tf:"policy,omitempty"`

	// (String) The zone's private key.
	// The zone's private key.
	PrivateKey *string `json:"privateKey,omitempty" tf:"private_key,omitempty"`

	// (String) The type 'legacy_custom' enables support for legacy clients which do not include SNI in the TLS handshake.
	// The type 'legacy_custom' enables support for legacy clients which do not include SNI in the TLS handshake.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// (String) Identifier
	// Identifier
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type SSLObservation_2 struct {

	// (String) A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
	// A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
	BundleMethod *string `json:"bundleMethod,omitempty" tf:"bundle_method,omitempty"`

	// (String) The zone's SSL certificate or certificate and the intermediate(s).
	// The zone's SSL certificate or certificate and the intermediate(s).
	Certificate *string `json:"certificate,omitempty" tf:"certificate,omitempty"`

	// (String) When the certificate from the authority expires.
	// When the certificate from the authority expires.
	ExpiresOn *string `json:"expiresOn,omitempty" tf:"expires_on,omitempty"`

	// (Attributes) Specify the region where your private key can be held locally for optimal TLS performance. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Options allow distribution to only to U.S. data centers, only to E.U. data centers, or only to highest security data centers. Default distribution is to all Cloudflare datacenters, for optimal performance. (see below for nested schema)
	GeoRestrictions *GeoRestrictionsObservation `json:"geoRestrictions,omitempty" tf:"geo_restrictions,omitempty"`

	// (List of String)
	Hosts []*string `json:"hosts,omitempty" tf:"hosts,omitempty"`

	// (String) Identifier
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (String) The certificate authority that issued the certificate.
	// The certificate authority that issued the certificate.
	Issuer *string `json:"issuer,omitempty" tf:"issuer,omitempty"`

	// (Attributes) (see below for nested schema)
	KeylessServer *KeylessServerObservation `json:"keylessServer,omitempty" tf:"keyless_server,omitempty"`

	// (String) When the certificate was last modified.
	// When the certificate was last modified.
	ModifiedOn *string `json:"modifiedOn,omitempty" tf:"modified_on,omitempty"`

	// 1_alpha-2#Officially_assigned_code_elements) can be chosen, such as 'country: IN', as well as 'region: EU' which refers to the EU region. If there are too few data centers satisfying the policy, it will be rejected.
	// Specify the policy that determines the region where your private key will be held locally. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Any combination of countries, specified by their two letter country code (https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements) can be chosen, such as 'country: IN', as well as 'region: EU' which refers to the EU region. If there are too few data centers satisfying the policy, it will be rejected.
	Policy *string `json:"policy,omitempty" tf:"policy,omitempty"`

	// (Number) The order/priority in which the certificate will be used in a request. The higher priority will break ties across overlapping 'legacy_custom' certificates, but 'legacy_custom' certificates will always supercede 'sni_custom' certificates.
	// The order/priority in which the certificate will be used in a request. The higher priority will break ties across overlapping 'legacy_custom' certificates, but 'legacy_custom' certificates will always supercede 'sni_custom' certificates.
	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`

	// (String) The zone's private key.
	// The zone's private key.
	PrivateKey *string `json:"privateKey,omitempty" tf:"private_key,omitempty"`

	// (String) The type of hash used for the certificate.
	// The type of hash used for the certificate.
	Signature *string `json:"signature,omitempty" tf:"signature,omitempty"`

	// (String) Status of the zone's custom SSL.
	// Status of the zone's custom SSL.
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	// (String) The type 'legacy_custom' enables support for legacy clients which do not include SNI in the TLS handshake.
	// The type 'legacy_custom' enables support for legacy clients which do not include SNI in the TLS handshake.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// (String) When the certificate was uploaded to Cloudflare.
	// When the certificate was uploaded to Cloudflare.
	UploadedOn *string `json:"uploadedOn,omitempty" tf:"uploaded_on,omitempty"`

	// (String) Identifier
	// Identifier
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type SSLParameters_2 struct {

	// (String) A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
	// A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
	// +kubebuilder:validation:Optional
	BundleMethod *string `json:"bundleMethod,omitempty" tf:"bundle_method,omitempty"`

	// (String) The zone's SSL certificate or certificate and the intermediate(s).
	// The zone's SSL certificate or certificate and the intermediate(s).
	// +kubebuilder:validation:Optional
	Certificate *string `json:"certificate,omitempty" tf:"certificate,omitempty"`

	// (Attributes) Specify the region where your private key can be held locally for optimal TLS performance. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Options allow distribution to only to U.S. data centers, only to E.U. data centers, or only to highest security data centers. Default distribution is to all Cloudflare datacenters, for optimal performance. (see below for nested schema)
	// +kubebuilder:validation:Optional
	GeoRestrictions *GeoRestrictionsParameters `json:"geoRestrictions,omitempty" tf:"geo_restrictions,omitempty"`

	// (Attributes) (see below for nested schema)
	// +kubebuilder:validation:Optional
	KeylessServer *KeylessServerParameters `json:"keylessServer,omitempty" tf:"keyless_server,omitempty"`

	// 1_alpha-2#Officially_assigned_code_elements) can be chosen, such as 'country: IN', as well as 'region: EU' which refers to the EU region. If there are too few data centers satisfying the policy, it will be rejected.
	// Specify the policy that determines the region where your private key will be held locally. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Any combination of countries, specified by their two letter country code (https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements) can be chosen, such as 'country: IN', as well as 'region: EU' which refers to the EU region. If there are too few data centers satisfying the policy, it will be rejected.
	// +kubebuilder:validation:Optional
	Policy *string `json:"policy,omitempty" tf:"policy,omitempty"`

	// (String) The zone's private key.
	// The zone's private key.
	// +kubebuilder:validation:Optional
	PrivateKey *string `json:"privateKey,omitempty" tf:"private_key,omitempty"`

	// (String) The type 'legacy_custom' enables support for legacy clients which do not include SNI in the TLS handshake.
	// The type 'legacy_custom' enables support for legacy clients which do not include SNI in the TLS handshake.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// (String) Identifier
	// Identifier
	// +kubebuilder:validation:Optional
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type TunnelInitParameters struct {
}

type TunnelObservation struct {

	// (String) Private IP of the Key Server Host
	// Private IP of the Key Server Host
	PrivateIP *string `json:"privateIp,omitempty" tf:"private_ip,omitempty"`

	// (String) Cloudflare Tunnel Virtual Network ID
	// Cloudflare Tunnel Virtual Network ID
	VnetID *string `json:"vnetId,omitempty" tf:"vnet_id,omitempty"`
}

type TunnelParameters struct {
}

// SSLSpec defines the desired state of SSL
type SSLSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     SSLParameters_2 `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider SSLInitParameters_2 `json:"initProvider,omitempty"`
}

// SSLStatus defines the observed state of SSL.
type SSLStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        SSLObservation_2 `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// SSL is the Schema for the SSLs API.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,cloudflare-upjet}
type SSL struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.certificate) || (has(self.initProvider) && has(self.initProvider.certificate))",message="spec.forProvider.certificate is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.privateKey) || (has(self.initProvider) && has(self.initProvider.privateKey))",message="spec.forProvider.privateKey is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.zoneId) || (has(self.initProvider) && has(self.initProvider.zoneId))",message="spec.forProvider.zoneId is a required parameter"
	Spec   SSLSpec   `json:"spec"`
	Status SSLStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// SSLList contains a list of SSLs
type SSLList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []SSL `json:"items"`
}

// Repository type metadata.
var (
	SSL_Kind             = "SSL"
	SSL_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: SSL_Kind}.String()
	SSL_KindAPIVersion   = SSL_Kind + "." + CRDGroupVersion.String()
	SSL_GroupVersionKind = CRDGroupVersion.WithKind(SSL_Kind)
)

func init() {
	SchemeBuilder.Register(&SSL{}, &SSLList{})
}
