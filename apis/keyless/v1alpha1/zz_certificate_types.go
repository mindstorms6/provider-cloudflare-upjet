// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type CertificateInitParameters struct {

	// (String) A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
	// A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
	BundleMethod *string `json:"bundleMethod,omitempty" tf:"bundle_method,omitempty"`

	// (String) The zone's SSL certificate or SSL certificate and intermediate(s).
	// The zone's SSL certificate or SSL certificate and intermediate(s).
	Certificate *string `json:"certificate,omitempty" tf:"certificate,omitempty"`

	// (Boolean) Whether or not the Keyless SSL is on or off.
	// Whether or not the Keyless SSL is on or off.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (String) The keyless SSL name.
	// The keyless SSL name.
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// (Number) The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
	// The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// (Attributes) Configuration for using Keyless SSL through a Cloudflare Tunnel (see below for nested schema)
	Tunnel *TunnelInitParameters `json:"tunnel,omitempty" tf:"tunnel,omitempty"`

	// (String) Identifier
	// Identifier
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type CertificateObservation struct {

	// (String) A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
	// A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
	BundleMethod *string `json:"bundleMethod,omitempty" tf:"bundle_method,omitempty"`

	// (String) The zone's SSL certificate or SSL certificate and intermediate(s).
	// The zone's SSL certificate or SSL certificate and intermediate(s).
	Certificate *string `json:"certificate,omitempty" tf:"certificate,omitempty"`

	// (String) When the Keyless SSL was created.
	// When the Keyless SSL was created.
	CreatedOn *string `json:"createdOn,omitempty" tf:"created_on,omitempty"`

	// (Boolean) Whether or not the Keyless SSL is on or off.
	// Whether or not the Keyless SSL is on or off.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (String) The keyless SSL name.
	// The keyless SSL name.
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// (String) Keyless certificate identifier tag.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (String) When the Keyless SSL was last modified.
	// When the Keyless SSL was last modified.
	ModifiedOn *string `json:"modifiedOn,omitempty" tf:"modified_on,omitempty"`

	// (List of String) Available permissions for the Keyless SSL for the current user requesting the item.
	// Available permissions for the Keyless SSL for the current user requesting the item.
	Permissions []*string `json:"permissions,omitempty" tf:"permissions,omitempty"`

	// (Number) The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
	// The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// (String) Status of the Keyless SSL.
	// Status of the Keyless SSL.
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	// (Attributes) Configuration for using Keyless SSL through a Cloudflare Tunnel (see below for nested schema)
	Tunnel *TunnelObservation `json:"tunnel,omitempty" tf:"tunnel,omitempty"`

	// (String) Identifier
	// Identifier
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type CertificateParameters struct {

	// (String) A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
	// A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
	// +kubebuilder:validation:Optional
	BundleMethod *string `json:"bundleMethod,omitempty" tf:"bundle_method,omitempty"`

	// (String) The zone's SSL certificate or SSL certificate and intermediate(s).
	// The zone's SSL certificate or SSL certificate and intermediate(s).
	// +kubebuilder:validation:Optional
	Certificate *string `json:"certificate,omitempty" tf:"certificate,omitempty"`

	// (Boolean) Whether or not the Keyless SSL is on or off.
	// Whether or not the Keyless SSL is on or off.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (String) The keyless SSL name.
	// The keyless SSL name.
	// +kubebuilder:validation:Optional
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// (Number) The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
	// The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// (Attributes) Configuration for using Keyless SSL through a Cloudflare Tunnel (see below for nested schema)
	// +kubebuilder:validation:Optional
	Tunnel *TunnelParameters `json:"tunnel,omitempty" tf:"tunnel,omitempty"`

	// (String) Identifier
	// Identifier
	// +kubebuilder:validation:Optional
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type TunnelInitParameters struct {

	// (String) Private IP of the Key Server Host
	// Private IP of the Key Server Host
	PrivateIP *string `json:"privateIp,omitempty" tf:"private_ip,omitempty"`

	// (String) Cloudflare Tunnel Virtual Network ID
	// Cloudflare Tunnel Virtual Network ID
	VnetID *string `json:"vnetId,omitempty" tf:"vnet_id,omitempty"`
}

type TunnelObservation struct {

	// (String) Private IP of the Key Server Host
	// Private IP of the Key Server Host
	PrivateIP *string `json:"privateIp,omitempty" tf:"private_ip,omitempty"`

	// (String) Cloudflare Tunnel Virtual Network ID
	// Cloudflare Tunnel Virtual Network ID
	VnetID *string `json:"vnetId,omitempty" tf:"vnet_id,omitempty"`
}

type TunnelParameters struct {

	// (String) Private IP of the Key Server Host
	// Private IP of the Key Server Host
	// +kubebuilder:validation:Optional
	PrivateIP *string `json:"privateIp" tf:"private_ip,omitempty"`

	// (String) Cloudflare Tunnel Virtual Network ID
	// Cloudflare Tunnel Virtual Network ID
	// +kubebuilder:validation:Optional
	VnetID *string `json:"vnetId" tf:"vnet_id,omitempty"`
}

// CertificateSpec defines the desired state of Certificate
type CertificateSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     CertificateParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider CertificateInitParameters `json:"initProvider,omitempty"`
}

// CertificateStatus defines the observed state of Certificate.
type CertificateStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        CertificateObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Certificate is the Schema for the Certificates API.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,cloudflare-upjet}
type Certificate struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.certificate) || (has(self.initProvider) && has(self.initProvider.certificate))",message="spec.forProvider.certificate is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.host) || (has(self.initProvider) && has(self.initProvider.host))",message="spec.forProvider.host is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.tunnel) || (has(self.initProvider) && has(self.initProvider.tunnel))",message="spec.forProvider.tunnel is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.zoneId) || (has(self.initProvider) && has(self.initProvider.zoneId))",message="spec.forProvider.zoneId is a required parameter"
	Spec   CertificateSpec   `json:"spec"`
	Status CertificateStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// CertificateList contains a list of Certificates
type CertificateList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Certificate `json:"items"`
}

// Repository type metadata.
var (
	Certificate_Kind             = "Certificate"
	Certificate_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Certificate_Kind}.String()
	Certificate_KindAPIVersion   = Certificate_Kind + "." + CRDGroupVersion.String()
	Certificate_GroupVersionKind = CRDGroupVersion.WithKind(Certificate_Kind)
)

func init() {
	SchemeBuilder.Register(&Certificate{}, &CertificateList{})
}
