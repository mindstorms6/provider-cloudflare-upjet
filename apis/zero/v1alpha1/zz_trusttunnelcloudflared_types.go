// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ConnectionsInitParameters struct {
}

type ConnectionsObservation struct {

	// (String) UUID of the Cloudflare Tunnel connector.
	// UUID of the Cloudflare Tunnel connector.
	ClientID *string `json:"clientId,omitempty" tf:"client_id,omitempty"`

	// (String) The cloudflared version used to establish this connection.
	// The cloudflared version used to establish this connection.
	ClientVersion *string `json:"clientVersion,omitempty" tf:"client_version,omitempty"`

	// (String) The Cloudflare data center used for this connection.
	// The Cloudflare data center used for this connection.
	ColoName *string `json:"coloName,omitempty" tf:"colo_name,omitempty"`

	// (String) UUID of the tunnel.
	// UUID of the Cloudflare Tunnel connection.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (Boolean) Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If true, the connection has disconnected but is still being tracked. If false, the connection is actively serving traffic.
	// Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If `true`, the connection has disconnected but is still being tracked. If `false`, the connection is actively serving traffic.
	IsPendingReconnect *bool `json:"isPendingReconnect,omitempty" tf:"is_pending_reconnect,omitempty"`

	// (String) Timestamp of when the connection was established.
	// Timestamp of when the connection was established.
	OpenedAt *string `json:"openedAt,omitempty" tf:"opened_at,omitempty"`

	// (String) The public IP address of the host running cloudflared.
	// The public IP address of the host running cloudflared.
	OriginIP *string `json:"originIp,omitempty" tf:"origin_ip,omitempty"`

	// (String) UUID of the Cloudflare Tunnel connection.
	// UUID of the Cloudflare Tunnel connection.
	UUID *string `json:"uuid,omitempty" tf:"uuid,omitempty"`
}

type ConnectionsParameters struct {
}

type TrustTunnelCloudflaredInitParameters struct {

	// (String) Cloudflare account ID
	// Cloudflare account ID
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	// (String) Indicates if this is a locally or remotely configured tunnel. If local, manage the tunnel using a YAML file on the origin machine. If cloudflare, manage the tunnel on the Zero Trust dashboard.
	// Indicates if this is a locally or remotely configured tunnel. If `local`, manage the tunnel using a YAML file on the origin machine. If `cloudflare`, manage the tunnel on the Zero Trust dashboard.
	ConfigSrc *string `json:"configSrc,omitempty" tf:"config_src,omitempty"`

	// (Attributes List) The Cloudflare Tunnel connections between your origin and Cloudflare's edge. (see below for nested schema)
	Connections []ConnectionsInitParameters `json:"connections,omitempty" tf:"connections,omitempty"`

	// managed tunnel. Must be at least 32 bytes and encoded as a base64 string.
	// Sets the password required to run a locally-managed tunnel. Must be at least 32 bytes and encoded as a base64 string.
	TunnelSecret *string `json:"tunnelSecret,omitempty" tf:"tunnel_secret,omitempty"`
}

type TrustTunnelCloudflaredObservation struct {

	// (String) Cloudflare account ID
	// Cloudflare account ID
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	// (String) Cloudflare account ID
	// Cloudflare account ID
	AccountTag *string `json:"accountTag,omitempty" tf:"account_tag,omitempty"`

	// (String) Indicates if this is a locally or remotely configured tunnel. If local, manage the tunnel using a YAML file on the origin machine. If cloudflare, manage the tunnel on the Zero Trust dashboard.
	// Indicates if this is a locally or remotely configured tunnel. If `local`, manage the tunnel using a YAML file on the origin machine. If `cloudflare`, manage the tunnel on the Zero Trust dashboard.
	ConfigSrc *string `json:"configSrc,omitempty" tf:"config_src,omitempty"`

	// (Attributes List) The Cloudflare Tunnel connections between your origin and Cloudflare's edge. (see below for nested schema)
	Connections []ConnectionsObservation `json:"connections,omitempty" tf:"connections,omitempty"`

	// (String) Timestamp of when the tunnel established at least one connection to Cloudflare's edge. If null, the tunnel is inactive.
	// Timestamp of when the tunnel established at least one connection to Cloudflare's edge. If `null`, the tunnel is inactive.
	ConnsActiveAt *string `json:"connsActiveAt,omitempty" tf:"conns_active_at,omitempty"`

	// (String) Timestamp of when the tunnel became inactive (no connections to Cloudflare's edge). If null, the tunnel is active.
	// Timestamp of when the tunnel became inactive (no connections to Cloudflare's edge). If `null`, the tunnel is active.
	ConnsInactiveAt *string `json:"connsInactiveAt,omitempty" tf:"conns_inactive_at,omitempty"`

	// (String) Timestamp of when the resource was created.
	// Timestamp of when the resource was created.
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	// (String) Timestamp of when the resource was deleted. If null, the resource has not been deleted.
	// Timestamp of when the resource was deleted. If `null`, the resource has not been deleted.
	DeletedAt *string `json:"deletedAt,omitempty" tf:"deleted_at,omitempty"`

	// (String) UUID of the tunnel.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (String) Metadata associated with the tunnel.
	// Metadata associated with the tunnel.
	Metadata *string `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// (Boolean) If true, the tunnel can be configured remotely from the Zero Trust dashboard. If false, the tunnel must be configured locally on the origin machine.
	// If `true`, the tunnel can be configured remotely from the Zero Trust dashboard. If `false`, the tunnel must be configured locally on the origin machine.
	RemoteConfig *bool `json:"remoteConfig,omitempty" tf:"remote_config,omitempty"`

	// (String) The status of the tunnel. Valid values are inactive (tunnel has never been run), degraded (tunnel is active and able to serve traffic but in an unhealthy state), healthy (tunnel is active and able to serve traffic), or down (tunnel can not serve traffic as it has no connections to the Cloudflare Edge).
	// The status of the tunnel. Valid values are `inactive` (tunnel has never been run), `degraded` (tunnel is active and able to serve traffic but in an unhealthy state), `healthy` (tunnel is active and able to serve traffic), or `down` (tunnel can not serve traffic as it has no connections to the Cloudflare Edge).
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	// (String) The type of tunnel.
	// The type of tunnel.
	TunType *string `json:"tunType,omitempty" tf:"tun_type,omitempty"`

	// managed tunnel. Must be at least 32 bytes and encoded as a base64 string.
	// Sets the password required to run a locally-managed tunnel. Must be at least 32 bytes and encoded as a base64 string.
	TunnelSecret *string `json:"tunnelSecret,omitempty" tf:"tunnel_secret,omitempty"`
}

type TrustTunnelCloudflaredParameters struct {

	// (String) Cloudflare account ID
	// Cloudflare account ID
	// +kubebuilder:validation:Optional
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	// (String) Indicates if this is a locally or remotely configured tunnel. If local, manage the tunnel using a YAML file on the origin machine. If cloudflare, manage the tunnel on the Zero Trust dashboard.
	// Indicates if this is a locally or remotely configured tunnel. If `local`, manage the tunnel using a YAML file on the origin machine. If `cloudflare`, manage the tunnel on the Zero Trust dashboard.
	// +kubebuilder:validation:Optional
	ConfigSrc *string `json:"configSrc,omitempty" tf:"config_src,omitempty"`

	// (Attributes List) The Cloudflare Tunnel connections between your origin and Cloudflare's edge. (see below for nested schema)
	// +kubebuilder:validation:Optional
	Connections []ConnectionsParameters `json:"connections,omitempty" tf:"connections,omitempty"`

	// managed tunnel. Must be at least 32 bytes and encoded as a base64 string.
	// Sets the password required to run a locally-managed tunnel. Must be at least 32 bytes and encoded as a base64 string.
	// +kubebuilder:validation:Optional
	TunnelSecret *string `json:"tunnelSecret,omitempty" tf:"tunnel_secret,omitempty"`
}

// TrustTunnelCloudflaredSpec defines the desired state of TrustTunnelCloudflared
type TrustTunnelCloudflaredSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     TrustTunnelCloudflaredParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider TrustTunnelCloudflaredInitParameters `json:"initProvider,omitempty"`
}

// TrustTunnelCloudflaredStatus defines the observed state of TrustTunnelCloudflared.
type TrustTunnelCloudflaredStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        TrustTunnelCloudflaredObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// TrustTunnelCloudflared is the Schema for the TrustTunnelCloudflareds API.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,cloudflare-upjet}
type TrustTunnelCloudflared struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.accountId) || (has(self.initProvider) && has(self.initProvider.accountId))",message="spec.forProvider.accountId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.connections) || (has(self.initProvider) && has(self.initProvider.connections))",message="spec.forProvider.connections is a required parameter"
	Spec   TrustTunnelCloudflaredSpec   `json:"spec"`
	Status TrustTunnelCloudflaredStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// TrustTunnelCloudflaredList contains a list of TrustTunnelCloudflareds
type TrustTunnelCloudflaredList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []TrustTunnelCloudflared `json:"items"`
}

// Repository type metadata.
var (
	TrustTunnelCloudflared_Kind             = "TrustTunnelCloudflared"
	TrustTunnelCloudflared_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: TrustTunnelCloudflared_Kind}.String()
	TrustTunnelCloudflared_KindAPIVersion   = TrustTunnelCloudflared_Kind + "." + CRDGroupVersion.String()
	TrustTunnelCloudflared_GroupVersionKind = CRDGroupVersion.WithKind(TrustTunnelCloudflared_Kind)
)

func init() {
	SchemeBuilder.Register(&TrustTunnelCloudflared{}, &TrustTunnelCloudflaredList{})
}
