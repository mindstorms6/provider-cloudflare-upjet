// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type DHCPRelayInitParameters struct {

	// (List of String) List of DHCP server IPs.
	// List of DHCP server IPs.
	ServerAddresses []*string `json:"serverAddresses,omitempty" tf:"server_addresses,omitempty"`
}

type DHCPRelayObservation struct {

	// (List of String) List of DHCP server IPs.
	// List of DHCP server IPs.
	ServerAddresses []*string `json:"serverAddresses,omitempty" tf:"server_addresses,omitempty"`
}

type DHCPRelayParameters struct {

	// (List of String) List of DHCP server IPs.
	// List of DHCP server IPs.
	// +kubebuilder:validation:Optional
	ServerAddresses []*string `json:"serverAddresses,omitempty" tf:"server_addresses,omitempty"`
}

type DHCPServerInitParameters struct {

	// (String) A valid IPv4 address.
	// A valid IPv4 address.
	DHCPPoolEnd *string `json:"dhcpPoolEnd,omitempty" tf:"dhcp_pool_end,omitempty"`

	// (String) A valid IPv4 address.
	// A valid IPv4 address.
	DHCPPoolStart *string `json:"dhcpPoolStart,omitempty" tf:"dhcp_pool_start,omitempty"`

	// (String) A valid IPv4 address.
	// A valid IPv4 address.
	DNSServer *string `json:"dnsServer,omitempty" tf:"dns_server,omitempty"`

	// (List of String)
	DNSServers []*string `json:"dnsServers,omitempty" tf:"dns_servers,omitempty"`

	// (Map of String) Mapping of MAC addresses to IP addresses
	// Mapping of MAC addresses to IP addresses
	// +mapType=granular
	Reservations map[string]*string `json:"reservations,omitempty" tf:"reservations,omitempty"`
}

type DHCPServerObservation struct {

	// (String) A valid IPv4 address.
	// A valid IPv4 address.
	DHCPPoolEnd *string `json:"dhcpPoolEnd,omitempty" tf:"dhcp_pool_end,omitempty"`

	// (String) A valid IPv4 address.
	// A valid IPv4 address.
	DHCPPoolStart *string `json:"dhcpPoolStart,omitempty" tf:"dhcp_pool_start,omitempty"`

	// (String) A valid IPv4 address.
	// A valid IPv4 address.
	DNSServer *string `json:"dnsServer,omitempty" tf:"dns_server,omitempty"`

	// (List of String)
	DNSServers []*string `json:"dnsServers,omitempty" tf:"dns_servers,omitempty"`

	// (Map of String) Mapping of MAC addresses to IP addresses
	// Mapping of MAC addresses to IP addresses
	// +mapType=granular
	Reservations map[string]*string `json:"reservations,omitempty" tf:"reservations,omitempty"`
}

type DHCPServerParameters struct {

	// (String) A valid IPv4 address.
	// A valid IPv4 address.
	// +kubebuilder:validation:Optional
	DHCPPoolEnd *string `json:"dhcpPoolEnd,omitempty" tf:"dhcp_pool_end,omitempty"`

	// (String) A valid IPv4 address.
	// A valid IPv4 address.
	// +kubebuilder:validation:Optional
	DHCPPoolStart *string `json:"dhcpPoolStart,omitempty" tf:"dhcp_pool_start,omitempty"`

	// (String) A valid IPv4 address.
	// A valid IPv4 address.
	// +kubebuilder:validation:Optional
	DNSServer *string `json:"dnsServer,omitempty" tf:"dns_server,omitempty"`

	// (List of String)
	// +kubebuilder:validation:Optional
	DNSServers []*string `json:"dnsServers,omitempty" tf:"dns_servers,omitempty"`

	// (Map of String) Mapping of MAC addresses to IP addresses
	// Mapping of MAC addresses to IP addresses
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Reservations map[string]*string `json:"reservations,omitempty" tf:"reservations,omitempty"`
}

type NATInitParameters struct {

	// (String) A valid CIDR notation representing an IP range.
	// A valid CIDR notation representing an IP range.
	StaticPrefix *string `json:"staticPrefix,omitempty" tf:"static_prefix,omitempty"`
}

type NATObservation struct {

	// (String) A valid CIDR notation representing an IP range.
	// A valid CIDR notation representing an IP range.
	StaticPrefix *string `json:"staticPrefix,omitempty" tf:"static_prefix,omitempty"`
}

type NATParameters struct {

	// (String) A valid CIDR notation representing an IP range.
	// A valid CIDR notation representing an IP range.
	// +kubebuilder:validation:Optional
	StaticPrefix *string `json:"staticPrefix,omitempty" tf:"static_prefix,omitempty"`
}

type RoutedSubnetsInitParameters struct {

	// (Attributes) (see below for nested schema)
	NAT *RoutedSubnetsNATInitParameters `json:"nat,omitempty" tf:"nat,omitempty"`

	// (String) A valid IPv4 address.
	// A valid IPv4 address.
	NextHop *string `json:"nextHop,omitempty" tf:"next_hop,omitempty"`

	// (String) A valid CIDR notation representing an IP range.
	// A valid CIDR notation representing an IP range.
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`
}

type RoutedSubnetsNATInitParameters struct {

	// (String) A valid CIDR notation representing an IP range.
	// A valid CIDR notation representing an IP range.
	StaticPrefix *string `json:"staticPrefix,omitempty" tf:"static_prefix,omitempty"`
}

type RoutedSubnetsNATObservation struct {

	// (String) A valid CIDR notation representing an IP range.
	// A valid CIDR notation representing an IP range.
	StaticPrefix *string `json:"staticPrefix,omitempty" tf:"static_prefix,omitempty"`
}

type RoutedSubnetsNATParameters struct {

	// (String) A valid CIDR notation representing an IP range.
	// A valid CIDR notation representing an IP range.
	// +kubebuilder:validation:Optional
	StaticPrefix *string `json:"staticPrefix,omitempty" tf:"static_prefix,omitempty"`
}

type RoutedSubnetsObservation struct {

	// (Attributes) (see below for nested schema)
	NAT *RoutedSubnetsNATObservation `json:"nat,omitempty" tf:"nat,omitempty"`

	// (String) A valid IPv4 address.
	// A valid IPv4 address.
	NextHop *string `json:"nextHop,omitempty" tf:"next_hop,omitempty"`

	// (String) A valid CIDR notation representing an IP range.
	// A valid CIDR notation representing an IP range.
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`
}

type RoutedSubnetsParameters struct {

	// (Attributes) (see below for nested schema)
	// +kubebuilder:validation:Optional
	NAT *RoutedSubnetsNATParameters `json:"nat,omitempty" tf:"nat,omitempty"`

	// (String) A valid IPv4 address.
	// A valid IPv4 address.
	// +kubebuilder:validation:Optional
	NextHop *string `json:"nextHop" tf:"next_hop,omitempty"`

	// (String) A valid CIDR notation representing an IP range.
	// A valid CIDR notation representing an IP range.
	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix" tf:"prefix,omitempty"`
}

type StaticAddressingInitParameters struct {

	// (String) A valid CIDR notation representing an IP range.
	// A valid CIDR notation representing an IP range.
	Address *string `json:"address,omitempty" tf:"address,omitempty"`

	// (Attributes) (see below for nested schema)
	DHCPRelay *DHCPRelayInitParameters `json:"dhcpRelay,omitempty" tf:"dhcp_relay,omitempty"`

	// (Attributes) (see below for nested schema)
	DHCPServer *DHCPServerInitParameters `json:"dhcpServer,omitempty" tf:"dhcp_server,omitempty"`

	// (String) A valid CIDR notation representing an IP range.
	// A valid CIDR notation representing an IP range.
	SecondaryAddress *string `json:"secondaryAddress,omitempty" tf:"secondary_address,omitempty"`

	// (String) A valid CIDR notation representing an IP range.
	// A valid CIDR notation representing an IP range.
	VirtualAddress *string `json:"virtualAddress,omitempty" tf:"virtual_address,omitempty"`
}

type StaticAddressingObservation struct {

	// (String) A valid CIDR notation representing an IP range.
	// A valid CIDR notation representing an IP range.
	Address *string `json:"address,omitempty" tf:"address,omitempty"`

	// (Attributes) (see below for nested schema)
	DHCPRelay *DHCPRelayObservation `json:"dhcpRelay,omitempty" tf:"dhcp_relay,omitempty"`

	// (Attributes) (see below for nested schema)
	DHCPServer *DHCPServerObservation `json:"dhcpServer,omitempty" tf:"dhcp_server,omitempty"`

	// (String) A valid CIDR notation representing an IP range.
	// A valid CIDR notation representing an IP range.
	SecondaryAddress *string `json:"secondaryAddress,omitempty" tf:"secondary_address,omitempty"`

	// (String) A valid CIDR notation representing an IP range.
	// A valid CIDR notation representing an IP range.
	VirtualAddress *string `json:"virtualAddress,omitempty" tf:"virtual_address,omitempty"`
}

type StaticAddressingParameters struct {

	// (String) A valid CIDR notation representing an IP range.
	// A valid CIDR notation representing an IP range.
	// +kubebuilder:validation:Optional
	Address *string `json:"address" tf:"address,omitempty"`

	// (Attributes) (see below for nested schema)
	// +kubebuilder:validation:Optional
	DHCPRelay *DHCPRelayParameters `json:"dhcpRelay,omitempty" tf:"dhcp_relay,omitempty"`

	// (Attributes) (see below for nested schema)
	// +kubebuilder:validation:Optional
	DHCPServer *DHCPServerParameters `json:"dhcpServer,omitempty" tf:"dhcp_server,omitempty"`

	// (String) A valid CIDR notation representing an IP range.
	// A valid CIDR notation representing an IP range.
	// +kubebuilder:validation:Optional
	SecondaryAddress *string `json:"secondaryAddress,omitempty" tf:"secondary_address,omitempty"`

	// (String) A valid CIDR notation representing an IP range.
	// A valid CIDR notation representing an IP range.
	// +kubebuilder:validation:Optional
	VirtualAddress *string `json:"virtualAddress,omitempty" tf:"virtual_address,omitempty"`
}

type TransitSiteLanInitParameters struct {

	// (String) Identifier
	// Identifier
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	// (Boolean) mark true to use this LAN for HA probing. only works for site with HA turned on. only one LAN can be set as the ha_link.
	// mark true to use this LAN for HA probing. only works for site with HA turned on. only one LAN can be set as the ha_link.
	HaLink *bool `json:"haLink,omitempty" tf:"ha_link,omitempty"`

	// (Attributes) (see below for nested schema)
	NAT *NATInitParameters `json:"nat,omitempty" tf:"nat,omitempty"`

	// (Number)
	Physport *float64 `json:"physport,omitempty" tf:"physport,omitempty"`

	// (Attributes List) (see below for nested schema)
	RoutedSubnets []RoutedSubnetsInitParameters `json:"routedSubnets,omitempty" tf:"routed_subnets,omitempty"`

	// (String) Identifier
	// Identifier
	SiteID *string `json:"siteId,omitempty" tf:"site_id,omitempty"`

	// (Attributes) If the site is not configured in high availability mode, this configuration is optional (if omitted, use DHCP). However, if in high availability mode, static_address is required along with secondary and virtual address. (see below for nested schema)
	StaticAddressing *StaticAddressingInitParameters `json:"staticAddressing,omitempty" tf:"static_addressing,omitempty"`

	// (Number) VLAN port number.
	// VLAN port number.
	VlanTag *float64 `json:"vlanTag,omitempty" tf:"vlan_tag,omitempty"`
}

type TransitSiteLanObservation struct {

	// (String) Identifier
	// Identifier
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	// (Boolean) mark true to use this LAN for HA probing. only works for site with HA turned on. only one LAN can be set as the ha_link.
	// mark true to use this LAN for HA probing. only works for site with HA turned on. only one LAN can be set as the ha_link.
	HaLink *bool `json:"haLink,omitempty" tf:"ha_link,omitempty"`

	// (String) Identifier
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (Attributes) (see below for nested schema)
	NAT *NATObservation `json:"nat,omitempty" tf:"nat,omitempty"`

	// (Number)
	Physport *float64 `json:"physport,omitempty" tf:"physport,omitempty"`

	// (Attributes List) (see below for nested schema)
	RoutedSubnets []RoutedSubnetsObservation `json:"routedSubnets,omitempty" tf:"routed_subnets,omitempty"`

	// (String) Identifier
	// Identifier
	SiteID *string `json:"siteId,omitempty" tf:"site_id,omitempty"`

	// (Attributes) If the site is not configured in high availability mode, this configuration is optional (if omitted, use DHCP). However, if in high availability mode, static_address is required along with secondary and virtual address. (see below for nested schema)
	StaticAddressing *StaticAddressingObservation `json:"staticAddressing,omitempty" tf:"static_addressing,omitempty"`

	// (Number) VLAN port number.
	// VLAN port number.
	VlanTag *float64 `json:"vlanTag,omitempty" tf:"vlan_tag,omitempty"`
}

type TransitSiteLanParameters struct {

	// (String) Identifier
	// Identifier
	// +kubebuilder:validation:Optional
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	// (Boolean) mark true to use this LAN for HA probing. only works for site with HA turned on. only one LAN can be set as the ha_link.
	// mark true to use this LAN for HA probing. only works for site with HA turned on. only one LAN can be set as the ha_link.
	// +kubebuilder:validation:Optional
	HaLink *bool `json:"haLink,omitempty" tf:"ha_link,omitempty"`

	// (Attributes) (see below for nested schema)
	// +kubebuilder:validation:Optional
	NAT *NATParameters `json:"nat,omitempty" tf:"nat,omitempty"`

	// (Number)
	// +kubebuilder:validation:Optional
	Physport *float64 `json:"physport,omitempty" tf:"physport,omitempty"`

	// (Attributes List) (see below for nested schema)
	// +kubebuilder:validation:Optional
	RoutedSubnets []RoutedSubnetsParameters `json:"routedSubnets,omitempty" tf:"routed_subnets,omitempty"`

	// (String) Identifier
	// Identifier
	// +kubebuilder:validation:Optional
	SiteID *string `json:"siteId,omitempty" tf:"site_id,omitempty"`

	// (Attributes) If the site is not configured in high availability mode, this configuration is optional (if omitted, use DHCP). However, if in high availability mode, static_address is required along with secondary and virtual address. (see below for nested schema)
	// +kubebuilder:validation:Optional
	StaticAddressing *StaticAddressingParameters `json:"staticAddressing,omitempty" tf:"static_addressing,omitempty"`

	// (Number) VLAN port number.
	// VLAN port number.
	// +kubebuilder:validation:Optional
	VlanTag *float64 `json:"vlanTag,omitempty" tf:"vlan_tag,omitempty"`
}

// TransitSiteLanSpec defines the desired state of TransitSiteLan
type TransitSiteLanSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     TransitSiteLanParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider TransitSiteLanInitParameters `json:"initProvider,omitempty"`
}

// TransitSiteLanStatus defines the observed state of TransitSiteLan.
type TransitSiteLanStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        TransitSiteLanObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// TransitSiteLan is the Schema for the TransitSiteLans API.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,cloudflare-upjet}
type TransitSiteLan struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.accountId) || (has(self.initProvider) && has(self.initProvider.accountId))",message="spec.forProvider.accountId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.physport) || (has(self.initProvider) && has(self.initProvider.physport))",message="spec.forProvider.physport is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.routedSubnets) || (has(self.initProvider) && has(self.initProvider.routedSubnets))",message="spec.forProvider.routedSubnets is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.siteId) || (has(self.initProvider) && has(self.initProvider.siteId))",message="spec.forProvider.siteId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.staticAddressing) || (has(self.initProvider) && has(self.initProvider.staticAddressing))",message="spec.forProvider.staticAddressing is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.vlanTag) || (has(self.initProvider) && has(self.initProvider.vlanTag))",message="spec.forProvider.vlanTag is a required parameter"
	Spec   TransitSiteLanSpec   `json:"spec"`
	Status TransitSiteLanStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// TransitSiteLanList contains a list of TransitSiteLans
type TransitSiteLanList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []TransitSiteLan `json:"items"`
}

// Repository type metadata.
var (
	TransitSiteLan_Kind             = "TransitSiteLan"
	TransitSiteLan_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: TransitSiteLan_Kind}.String()
	TransitSiteLan_KindAPIVersion   = TransitSiteLan_Kind + "." + CRDGroupVersion.String()
	TransitSiteLan_GroupVersionKind = CRDGroupVersion.WithKind(TransitSiteLan_Kind)
)

func init() {
	SchemeBuilder.Register(&TransitSiteLan{}, &TransitSiteLanList{})
}
