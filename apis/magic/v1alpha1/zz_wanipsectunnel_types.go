// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type IpsecTunnelHealthCheckInitParameters struct {

	// magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false. (see below for nested schema)
	Target *IpsecTunnelHealthCheckTargetInitParameters `json:"target,omitempty" tf:"target,omitempty"`
}

type IpsecTunnelHealthCheckObservation struct {

	// (String) The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
	// The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
	Direction *string `json:"direction,omitempty" tf:"direction,omitempty"`

	// (Boolean) Determines whether to run healthchecks for a tunnel.
	// Determines whether to run healthchecks for a tunnel.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (String) How frequent the health check is run. The default value is mid.
	// How frequent the health check is run. The default value is `mid`.
	Rate *string `json:"rate,omitempty" tf:"rate,omitempty"`

	// magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false. (see below for nested schema)
	Target *IpsecTunnelHealthCheckTargetObservation `json:"target,omitempty" tf:"target,omitempty"`

	// (String) The type of healthcheck to run, reply or request. The default value is reply.
	// The type of healthcheck to run, reply or request. The default value is `reply`.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type IpsecTunnelHealthCheckParameters struct {

	// magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false. (see below for nested schema)
	// +kubebuilder:validation:Optional
	Target *IpsecTunnelHealthCheckTargetParameters `json:"target,omitempty" tf:"target,omitempty"`
}

type IpsecTunnelHealthCheckTargetInitParameters struct {
}

type IpsecTunnelHealthCheckTargetObservation struct {

	// (String) The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
	// The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
	Effective *string `json:"effective,omitempty" tf:"effective,omitempty"`

	// (String) The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
	// The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
	Saved *string `json:"saved,omitempty" tf:"saved,omitempty"`
}

type IpsecTunnelHealthCheckTargetParameters struct {
}

type IpsecTunnelInitParameters struct {

	// (Attributes) (see below for nested schema)
	HealthCheck *IpsecTunnelHealthCheckInitParameters `json:"healthCheck,omitempty" tf:"health_check,omitempty"`

	// (Attributes) The PSK metadata that includes when the PSK was generated. (see below for nested schema)
	PskMetadata *PskMetadataInitParameters `json:"pskMetadata,omitempty" tf:"psk_metadata,omitempty"`
}

type IpsecTunnelObservation struct {

	// cipher (ENCR_NULL) in the ESP tunnel (Phase 2).
	// When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).
	AllowNullCipher *bool `json:"allowNullCipher,omitempty" tf:"allow_null_cipher,omitempty"`

	// (String) The IP address assigned to the Cloudflare side of the IPsec tunnel.
	// The IP address assigned to the Cloudflare side of the IPsec tunnel.
	CloudflareEndpoint *string `json:"cloudflareEndpoint,omitempty" tf:"cloudflare_endpoint,omitempty"`

	// (String) The date and time the tunnel was created.
	// The date and time the tunnel was created.
	CreatedOn *string `json:"createdOn,omitempty" tf:"created_on,omitempty"`

	// (String) The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.
	// The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.
	CustomerEndpoint *string `json:"customerEndpoint,omitempty" tf:"customer_endpoint,omitempty"`

	// (String) An optional description forthe IPsec tunnel.
	// An optional description forthe IPsec tunnel.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Attributes) (see below for nested schema)
	HealthCheck *IpsecTunnelHealthCheckObservation `json:"healthCheck,omitempty" tf:"health_check,omitempty"`

	// (String) Tunnel identifier tag.
	// Tunnel identifier tag.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
	// A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
	InterfaceAddress *string `json:"interfaceAddress,omitempty" tf:"interface_address,omitempty"`

	// (String) The date and time the tunnel was last modified.
	// The date and time the tunnel was last modified.
	ModifiedOn *string `json:"modifiedOn,omitempty" tf:"modified_on,omitempty"`

	// (String) The name of the IPsec tunnel. The name cannot share a name with other tunnels.
	// The name of the IPsec tunnel. The name cannot share a name with other tunnels.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Attributes) The PSK metadata that includes when the PSK was generated. (see below for nested schema)
	PskMetadata *PskMetadataObservation `json:"pskMetadata,omitempty" tf:"psk_metadata,omitempty"`

	// to-customer direction.
	// If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.
	ReplayProtection *bool `json:"replayProtection,omitempty" tf:"replay_protection,omitempty"`
}

type IpsecTunnelParameters struct {

	// (Attributes) (see below for nested schema)
	// +kubebuilder:validation:Optional
	HealthCheck *IpsecTunnelHealthCheckParameters `json:"healthCheck,omitempty" tf:"health_check,omitempty"`

	// (Attributes) The PSK metadata that includes when the PSK was generated. (see below for nested schema)
	// +kubebuilder:validation:Optional
	PskMetadata *PskMetadataParameters `json:"pskMetadata,omitempty" tf:"psk_metadata,omitempty"`
}

type IpsecTunnelsHealthCheckInitParameters struct {

	// magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false. (see below for nested schema)
	Target *IpsecTunnelsHealthCheckTargetInitParameters `json:"target,omitempty" tf:"target,omitempty"`
}

type IpsecTunnelsHealthCheckObservation struct {

	// (String) The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
	// The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
	Direction *string `json:"direction,omitempty" tf:"direction,omitempty"`

	// (Boolean) Determines whether to run healthchecks for a tunnel.
	// Determines whether to run healthchecks for a tunnel.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (String) How frequent the health check is run. The default value is mid.
	// How frequent the health check is run. The default value is `mid`.
	Rate *string `json:"rate,omitempty" tf:"rate,omitempty"`

	// magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false. (see below for nested schema)
	Target *IpsecTunnelsHealthCheckTargetObservation `json:"target,omitempty" tf:"target,omitempty"`

	// (String) The type of healthcheck to run, reply or request. The default value is reply.
	// The type of healthcheck to run, reply or request. The default value is `reply`.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type IpsecTunnelsHealthCheckParameters struct {

	// magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false. (see below for nested schema)
	// +kubebuilder:validation:Optional
	Target *IpsecTunnelsHealthCheckTargetParameters `json:"target,omitempty" tf:"target,omitempty"`
}

type IpsecTunnelsHealthCheckTargetInitParameters struct {
}

type IpsecTunnelsHealthCheckTargetObservation struct {

	// (String) The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
	// The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
	Effective *string `json:"effective,omitempty" tf:"effective,omitempty"`

	// (String) The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
	// The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
	Saved *string `json:"saved,omitempty" tf:"saved,omitempty"`
}

type IpsecTunnelsHealthCheckTargetParameters struct {
}

type IpsecTunnelsInitParameters struct {

	// (Attributes) (see below for nested schema)
	HealthCheck *IpsecTunnelsHealthCheckInitParameters `json:"healthCheck,omitempty" tf:"health_check,omitempty"`

	// (Attributes) The PSK metadata that includes when the PSK was generated. (see below for nested schema)
	PskMetadata *IpsecTunnelsPskMetadataInitParameters `json:"pskMetadata,omitempty" tf:"psk_metadata,omitempty"`
}

type IpsecTunnelsObservation struct {

	// cipher (ENCR_NULL) in the ESP tunnel (Phase 2).
	// When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).
	AllowNullCipher *bool `json:"allowNullCipher,omitempty" tf:"allow_null_cipher,omitempty"`

	// (String) The IP address assigned to the Cloudflare side of the IPsec tunnel.
	// The IP address assigned to the Cloudflare side of the IPsec tunnel.
	CloudflareEndpoint *string `json:"cloudflareEndpoint,omitempty" tf:"cloudflare_endpoint,omitempty"`

	// (String) The date and time the tunnel was created.
	// The date and time the tunnel was created.
	CreatedOn *string `json:"createdOn,omitempty" tf:"created_on,omitempty"`

	// (String) The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.
	// The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.
	CustomerEndpoint *string `json:"customerEndpoint,omitempty" tf:"customer_endpoint,omitempty"`

	// (String) An optional description forthe IPsec tunnel.
	// An optional description forthe IPsec tunnel.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Attributes) (see below for nested schema)
	HealthCheck *IpsecTunnelsHealthCheckObservation `json:"healthCheck,omitempty" tf:"health_check,omitempty"`

	// (String) Tunnel identifier tag.
	// Tunnel identifier tag.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
	// A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
	InterfaceAddress *string `json:"interfaceAddress,omitempty" tf:"interface_address,omitempty"`

	// (String) The date and time the tunnel was last modified.
	// The date and time the tunnel was last modified.
	ModifiedOn *string `json:"modifiedOn,omitempty" tf:"modified_on,omitempty"`

	// (String) The name of the IPsec tunnel. The name cannot share a name with other tunnels.
	// The name of the IPsec tunnel. The name cannot share a name with other tunnels.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Attributes) The PSK metadata that includes when the PSK was generated. (see below for nested schema)
	PskMetadata *IpsecTunnelsPskMetadataObservation `json:"pskMetadata,omitempty" tf:"psk_metadata,omitempty"`

	// to-customer direction.
	// If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.
	ReplayProtection *bool `json:"replayProtection,omitempty" tf:"replay_protection,omitempty"`
}

type IpsecTunnelsParameters struct {

	// (Attributes) (see below for nested schema)
	// +kubebuilder:validation:Optional
	HealthCheck *IpsecTunnelsHealthCheckParameters `json:"healthCheck,omitempty" tf:"health_check,omitempty"`

	// (Attributes) The PSK metadata that includes when the PSK was generated. (see below for nested schema)
	// +kubebuilder:validation:Optional
	PskMetadata *IpsecTunnelsPskMetadataParameters `json:"pskMetadata,omitempty" tf:"psk_metadata,omitempty"`
}

type IpsecTunnelsPskMetadataInitParameters struct {
}

type IpsecTunnelsPskMetadataObservation struct {

	// (String) The date and time the tunnel was last modified.
	// The date and time the tunnel was last modified.
	LastGeneratedOn *string `json:"lastGeneratedOn,omitempty" tf:"last_generated_on,omitempty"`
}

type IpsecTunnelsPskMetadataParameters struct {
}

type ModifiedIpsecTunnelHealthCheckInitParameters struct {

	// magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false. (see below for nested schema)
	Target *ModifiedIpsecTunnelHealthCheckTargetInitParameters `json:"target,omitempty" tf:"target,omitempty"`
}

type ModifiedIpsecTunnelHealthCheckObservation struct {

	// (String) The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
	// The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
	Direction *string `json:"direction,omitempty" tf:"direction,omitempty"`

	// (Boolean) Determines whether to run healthchecks for a tunnel.
	// Determines whether to run healthchecks for a tunnel.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (String) How frequent the health check is run. The default value is mid.
	// How frequent the health check is run. The default value is `mid`.
	Rate *string `json:"rate,omitempty" tf:"rate,omitempty"`

	// magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false. (see below for nested schema)
	Target *ModifiedIpsecTunnelHealthCheckTargetObservation `json:"target,omitempty" tf:"target,omitempty"`

	// (String) The type of healthcheck to run, reply or request. The default value is reply.
	// The type of healthcheck to run, reply or request. The default value is `reply`.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ModifiedIpsecTunnelHealthCheckParameters struct {

	// magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false. (see below for nested schema)
	// +kubebuilder:validation:Optional
	Target *ModifiedIpsecTunnelHealthCheckTargetParameters `json:"target,omitempty" tf:"target,omitempty"`
}

type ModifiedIpsecTunnelHealthCheckTargetInitParameters struct {
}

type ModifiedIpsecTunnelHealthCheckTargetObservation struct {

	// (String) The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
	// The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
	Effective *string `json:"effective,omitempty" tf:"effective,omitempty"`

	// (String) The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
	// The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
	Saved *string `json:"saved,omitempty" tf:"saved,omitempty"`
}

type ModifiedIpsecTunnelHealthCheckTargetParameters struct {
}

type ModifiedIpsecTunnelInitParameters struct {

	// (Attributes) (see below for nested schema)
	HealthCheck *ModifiedIpsecTunnelHealthCheckInitParameters `json:"healthCheck,omitempty" tf:"health_check,omitempty"`

	// (Attributes) The PSK metadata that includes when the PSK was generated. (see below for nested schema)
	PskMetadata *ModifiedIpsecTunnelPskMetadataInitParameters `json:"pskMetadata,omitempty" tf:"psk_metadata,omitempty"`
}

type ModifiedIpsecTunnelObservation struct {

	// cipher (ENCR_NULL) in the ESP tunnel (Phase 2).
	// When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).
	AllowNullCipher *bool `json:"allowNullCipher,omitempty" tf:"allow_null_cipher,omitempty"`

	// (String) The IP address assigned to the Cloudflare side of the IPsec tunnel.
	// The IP address assigned to the Cloudflare side of the IPsec tunnel.
	CloudflareEndpoint *string `json:"cloudflareEndpoint,omitempty" tf:"cloudflare_endpoint,omitempty"`

	// (String) The date and time the tunnel was created.
	// The date and time the tunnel was created.
	CreatedOn *string `json:"createdOn,omitempty" tf:"created_on,omitempty"`

	// (String) The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.
	// The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.
	CustomerEndpoint *string `json:"customerEndpoint,omitempty" tf:"customer_endpoint,omitempty"`

	// (String) An optional description forthe IPsec tunnel.
	// An optional description forthe IPsec tunnel.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Attributes) (see below for nested schema)
	HealthCheck *ModifiedIpsecTunnelHealthCheckObservation `json:"healthCheck,omitempty" tf:"health_check,omitempty"`

	// (String) Tunnel identifier tag.
	// Tunnel identifier tag.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
	// A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
	InterfaceAddress *string `json:"interfaceAddress,omitempty" tf:"interface_address,omitempty"`

	// (String) The date and time the tunnel was last modified.
	// The date and time the tunnel was last modified.
	ModifiedOn *string `json:"modifiedOn,omitempty" tf:"modified_on,omitempty"`

	// (String) The name of the IPsec tunnel. The name cannot share a name with other tunnels.
	// The name of the IPsec tunnel. The name cannot share a name with other tunnels.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Attributes) The PSK metadata that includes when the PSK was generated. (see below for nested schema)
	PskMetadata *ModifiedIpsecTunnelPskMetadataObservation `json:"pskMetadata,omitempty" tf:"psk_metadata,omitempty"`

	// to-customer direction.
	// If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.
	ReplayProtection *bool `json:"replayProtection,omitempty" tf:"replay_protection,omitempty"`
}

type ModifiedIpsecTunnelParameters struct {

	// (Attributes) (see below for nested schema)
	// +kubebuilder:validation:Optional
	HealthCheck *ModifiedIpsecTunnelHealthCheckParameters `json:"healthCheck,omitempty" tf:"health_check,omitempty"`

	// (Attributes) The PSK metadata that includes when the PSK was generated. (see below for nested schema)
	// +kubebuilder:validation:Optional
	PskMetadata *ModifiedIpsecTunnelPskMetadataParameters `json:"pskMetadata,omitempty" tf:"psk_metadata,omitempty"`
}

type ModifiedIpsecTunnelPskMetadataInitParameters struct {
}

type ModifiedIpsecTunnelPskMetadataObservation struct {

	// (String) The date and time the tunnel was last modified.
	// The date and time the tunnel was last modified.
	LastGeneratedOn *string `json:"lastGeneratedOn,omitempty" tf:"last_generated_on,omitempty"`
}

type ModifiedIpsecTunnelPskMetadataParameters struct {
}

type PskMetadataInitParameters struct {
}

type PskMetadataObservation struct {

	// (String) The date and time the tunnel was last modified.
	// The date and time the tunnel was last modified.
	LastGeneratedOn *string `json:"lastGeneratedOn,omitempty" tf:"last_generated_on,omitempty"`
}

type PskMetadataParameters struct {
}

type WanIpsecTunnelHealthCheckInitParameters struct {

	// (String) The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
	// The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
	Direction *string `json:"direction,omitempty" tf:"direction,omitempty"`

	// (Boolean) Determines whether to run healthchecks for a tunnel.
	// Determines whether to run healthchecks for a tunnel.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (String) How frequent the health check is run. The default value is mid.
	// How frequent the health check is run. The default value is `mid`.
	Rate *string `json:"rate,omitempty" tf:"rate,omitempty"`

	// magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false. (see below for nested schema)
	Target *WanIpsecTunnelHealthCheckTargetInitParameters `json:"target,omitempty" tf:"target,omitempty"`

	// (String) The type of healthcheck to run, reply or request. The default value is reply.
	// The type of healthcheck to run, reply or request. The default value is `reply`.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type WanIpsecTunnelHealthCheckObservation struct {

	// (String) The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
	// The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
	Direction *string `json:"direction,omitempty" tf:"direction,omitempty"`

	// (Boolean) Determines whether to run healthchecks for a tunnel.
	// Determines whether to run healthchecks for a tunnel.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (String) How frequent the health check is run. The default value is mid.
	// How frequent the health check is run. The default value is `mid`.
	Rate *string `json:"rate,omitempty" tf:"rate,omitempty"`

	// magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false. (see below for nested schema)
	Target *WanIpsecTunnelHealthCheckTargetObservation `json:"target,omitempty" tf:"target,omitempty"`

	// (String) The type of healthcheck to run, reply or request. The default value is reply.
	// The type of healthcheck to run, reply or request. The default value is `reply`.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type WanIpsecTunnelHealthCheckParameters struct {

	// (String) The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
	// The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
	// +kubebuilder:validation:Optional
	Direction *string `json:"direction,omitempty" tf:"direction,omitempty"`

	// (Boolean) Determines whether to run healthchecks for a tunnel.
	// Determines whether to run healthchecks for a tunnel.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// (String) How frequent the health check is run. The default value is mid.
	// How frequent the health check is run. The default value is `mid`.
	// +kubebuilder:validation:Optional
	Rate *string `json:"rate,omitempty" tf:"rate,omitempty"`

	// magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false. (see below for nested schema)
	// +kubebuilder:validation:Optional
	Target *WanIpsecTunnelHealthCheckTargetParameters `json:"target,omitempty" tf:"target,omitempty"`

	// (String) The type of healthcheck to run, reply or request. The default value is reply.
	// The type of healthcheck to run, reply or request. The default value is `reply`.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type WanIpsecTunnelHealthCheckTargetInitParameters struct {

	// (String) The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
	// The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
	Saved *string `json:"saved,omitempty" tf:"saved,omitempty"`
}

type WanIpsecTunnelHealthCheckTargetObservation struct {

	// (String) The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
	// The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
	Effective *string `json:"effective,omitempty" tf:"effective,omitempty"`

	// (String) The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
	// The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
	Saved *string `json:"saved,omitempty" tf:"saved,omitempty"`
}

type WanIpsecTunnelHealthCheckTargetParameters struct {

	// (String) The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
	// The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
	// +kubebuilder:validation:Optional
	Saved *string `json:"saved,omitempty" tf:"saved,omitempty"`
}

type WanIpsecTunnelInitParameters struct {

	// (String) Identifier
	// Identifier
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	// (String) The IP address assigned to the Cloudflare side of the IPsec tunnel.
	// The IP address assigned to the Cloudflare side of the IPsec tunnel.
	CloudflareEndpoint *string `json:"cloudflareEndpoint,omitempty" tf:"cloudflare_endpoint,omitempty"`

	// (String) The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.
	// The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.
	CustomerEndpoint *string `json:"customerEndpoint,omitempty" tf:"customer_endpoint,omitempty"`

	// (String) An optional description forthe IPsec tunnel.
	// An optional description forthe IPsec tunnel.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Attributes) (see below for nested schema)
	HealthCheck *WanIpsecTunnelHealthCheckInitParameters `json:"healthCheck,omitempty" tf:"health_check,omitempty"`

	// bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
	// A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
	InterfaceAddress *string `json:"interfaceAddress,omitempty" tf:"interface_address,omitempty"`

	// (Attributes) (see below for nested schema)
	IpsecTunnel *IpsecTunnelInitParameters `json:"ipsecTunnel,omitempty" tf:"ipsec_tunnel,omitempty"`

	// (String) Identifier
	// Identifier
	IpsecTunnelID *string `json:"ipsecTunnelId,omitempty" tf:"ipsec_tunnel_id,omitempty"`

	// (Attributes List) (see below for nested schema)
	IpsecTunnels []IpsecTunnelsInitParameters `json:"ipsecTunnels,omitempty" tf:"ipsec_tunnels,omitempty"`

	// (Attributes) (see below for nested schema)
	ModifiedIpsecTunnel *ModifiedIpsecTunnelInitParameters `json:"modifiedIpsecTunnel,omitempty" tf:"modified_ipsec_tunnel,omitempty"`

	// (String) A randomly generated or provided string for use in the IPsec tunnel.
	// A randomly generated or provided string for use in the IPsec tunnel.
	Psk *string `json:"psk,omitempty" tf:"psk,omitempty"`

	// to-customer direction.
	// If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.
	ReplayProtection *bool `json:"replayProtection,omitempty" tf:"replay_protection,omitempty"`
}

type WanIpsecTunnelObservation struct {

	// (String) Identifier
	// Identifier
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	// (String) The IP address assigned to the Cloudflare side of the IPsec tunnel.
	// The IP address assigned to the Cloudflare side of the IPsec tunnel.
	CloudflareEndpoint *string `json:"cloudflareEndpoint,omitempty" tf:"cloudflare_endpoint,omitempty"`

	// (String) The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.
	// The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.
	CustomerEndpoint *string `json:"customerEndpoint,omitempty" tf:"customer_endpoint,omitempty"`

	// (String) An optional description forthe IPsec tunnel.
	// An optional description forthe IPsec tunnel.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Attributes) (see below for nested schema)
	HealthCheck *WanIpsecTunnelHealthCheckObservation `json:"healthCheck,omitempty" tf:"health_check,omitempty"`

	// (String) Tunnel identifier tag.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
	// A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
	InterfaceAddress *string `json:"interfaceAddress,omitempty" tf:"interface_address,omitempty"`

	// (Attributes) (see below for nested schema)
	IpsecTunnel *IpsecTunnelObservation `json:"ipsecTunnel,omitempty" tf:"ipsec_tunnel,omitempty"`

	// (String) Identifier
	// Identifier
	IpsecTunnelID *string `json:"ipsecTunnelId,omitempty" tf:"ipsec_tunnel_id,omitempty"`

	// (Attributes List) (see below for nested schema)
	IpsecTunnels []IpsecTunnelsObservation `json:"ipsecTunnels,omitempty" tf:"ipsec_tunnels,omitempty"`

	// (Boolean)
	Modified *bool `json:"modified,omitempty" tf:"modified,omitempty"`

	// (Attributes) (see below for nested schema)
	ModifiedIpsecTunnel *ModifiedIpsecTunnelObservation `json:"modifiedIpsecTunnel,omitempty" tf:"modified_ipsec_tunnel,omitempty"`

	// (String) A randomly generated or provided string for use in the IPsec tunnel.
	// A randomly generated or provided string for use in the IPsec tunnel.
	Psk *string `json:"psk,omitempty" tf:"psk,omitempty"`

	// to-customer direction.
	// If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.
	ReplayProtection *bool `json:"replayProtection,omitempty" tf:"replay_protection,omitempty"`
}

type WanIpsecTunnelParameters struct {

	// (String) Identifier
	// Identifier
	// +kubebuilder:validation:Optional
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	// (String) The IP address assigned to the Cloudflare side of the IPsec tunnel.
	// The IP address assigned to the Cloudflare side of the IPsec tunnel.
	// +kubebuilder:validation:Optional
	CloudflareEndpoint *string `json:"cloudflareEndpoint,omitempty" tf:"cloudflare_endpoint,omitempty"`

	// (String) The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.
	// The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.
	// +kubebuilder:validation:Optional
	CustomerEndpoint *string `json:"customerEndpoint,omitempty" tf:"customer_endpoint,omitempty"`

	// (String) An optional description forthe IPsec tunnel.
	// An optional description forthe IPsec tunnel.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Attributes) (see below for nested schema)
	// +kubebuilder:validation:Optional
	HealthCheck *WanIpsecTunnelHealthCheckParameters `json:"healthCheck,omitempty" tf:"health_check,omitempty"`

	// bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
	// A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
	// +kubebuilder:validation:Optional
	InterfaceAddress *string `json:"interfaceAddress,omitempty" tf:"interface_address,omitempty"`

	// (Attributes) (see below for nested schema)
	// +kubebuilder:validation:Optional
	IpsecTunnel *IpsecTunnelParameters `json:"ipsecTunnel,omitempty" tf:"ipsec_tunnel,omitempty"`

	// (String) Identifier
	// Identifier
	// +kubebuilder:validation:Optional
	IpsecTunnelID *string `json:"ipsecTunnelId,omitempty" tf:"ipsec_tunnel_id,omitempty"`

	// (Attributes List) (see below for nested schema)
	// +kubebuilder:validation:Optional
	IpsecTunnels []IpsecTunnelsParameters `json:"ipsecTunnels,omitempty" tf:"ipsec_tunnels,omitempty"`

	// (Attributes) (see below for nested schema)
	// +kubebuilder:validation:Optional
	ModifiedIpsecTunnel *ModifiedIpsecTunnelParameters `json:"modifiedIpsecTunnel,omitempty" tf:"modified_ipsec_tunnel,omitempty"`

	// (String) A randomly generated or provided string for use in the IPsec tunnel.
	// A randomly generated or provided string for use in the IPsec tunnel.
	// +kubebuilder:validation:Optional
	Psk *string `json:"psk,omitempty" tf:"psk,omitempty"`

	// to-customer direction.
	// If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.
	// +kubebuilder:validation:Optional
	ReplayProtection *bool `json:"replayProtection,omitempty" tf:"replay_protection,omitempty"`
}

// WanIpsecTunnelSpec defines the desired state of WanIpsecTunnel
type WanIpsecTunnelSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     WanIpsecTunnelParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider WanIpsecTunnelInitParameters `json:"initProvider,omitempty"`
}

// WanIpsecTunnelStatus defines the observed state of WanIpsecTunnel.
type WanIpsecTunnelStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        WanIpsecTunnelObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// WanIpsecTunnel is the Schema for the WanIpsecTunnels API.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,cloudflare-upjet}
type WanIpsecTunnel struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.accountId) || (has(self.initProvider) && has(self.initProvider.accountId))",message="spec.forProvider.accountId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.cloudflareEndpoint) || (has(self.initProvider) && has(self.initProvider.cloudflareEndpoint))",message="spec.forProvider.cloudflareEndpoint is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.interfaceAddress) || (has(self.initProvider) && has(self.initProvider.interfaceAddress))",message="spec.forProvider.interfaceAddress is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.ipsecTunnels) || (has(self.initProvider) && has(self.initProvider.ipsecTunnels))",message="spec.forProvider.ipsecTunnels is a required parameter"
	Spec   WanIpsecTunnelSpec   `json:"spec"`
	Status WanIpsecTunnelStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// WanIpsecTunnelList contains a list of WanIpsecTunnels
type WanIpsecTunnelList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []WanIpsecTunnel `json:"items"`
}

// Repository type metadata.
var (
	WanIpsecTunnel_Kind             = "WanIpsecTunnel"
	WanIpsecTunnel_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: WanIpsecTunnel_Kind}.String()
	WanIpsecTunnel_KindAPIVersion   = WanIpsecTunnel_Kind + "." + CRDGroupVersion.String()
	WanIpsecTunnel_GroupVersionKind = CRDGroupVersion.WithKind(WanIpsecTunnel_Kind)
)

func init() {
	SchemeBuilder.Register(&WanIpsecTunnel{}, &WanIpsecTunnelList{})
}
