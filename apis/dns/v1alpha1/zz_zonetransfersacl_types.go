// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ZoneTransfersACLInitParameters struct {

	// (String)
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	// (String) Allowed IPv4/IPv6 address range of primary or secondary nameservers. This will be applied for the entire account. The IP range is used to allow additional NOTIFY IPs for secondary zones and IPs Cloudflare allows AXFR/IXFR requests from for primary zones. CIDRs are limited to a maximum of /24 for IPv4 and /64 for IPv6 respectively.
	// Allowed IPv4/IPv6 address range of primary or secondary nameservers. This will be applied for the entire account. The IP range is used to allow additional NOTIFY IPs for secondary zones and IPs Cloudflare allows AXFR/IXFR requests from for primary zones. CIDRs are limited to a maximum of /24 for IPv4 and /64 for IPv6 respectively.
	IPRange *string `json:"ipRange,omitempty" tf:"ip_range,omitempty"`
}

type ZoneTransfersACLObservation struct {

	// (String)
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (String) Allowed IPv4/IPv6 address range of primary or secondary nameservers. This will be applied for the entire account. The IP range is used to allow additional NOTIFY IPs for secondary zones and IPs Cloudflare allows AXFR/IXFR requests from for primary zones. CIDRs are limited to a maximum of /24 for IPv4 and /64 for IPv6 respectively.
	// Allowed IPv4/IPv6 address range of primary or secondary nameservers. This will be applied for the entire account. The IP range is used to allow additional NOTIFY IPs for secondary zones and IPs Cloudflare allows AXFR/IXFR requests from for primary zones. CIDRs are limited to a maximum of /24 for IPv4 and /64 for IPv6 respectively.
	IPRange *string `json:"ipRange,omitempty" tf:"ip_range,omitempty"`
}

type ZoneTransfersACLParameters struct {

	// (String)
	// +kubebuilder:validation:Optional
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	// (String) Allowed IPv4/IPv6 address range of primary or secondary nameservers. This will be applied for the entire account. The IP range is used to allow additional NOTIFY IPs for secondary zones and IPs Cloudflare allows AXFR/IXFR requests from for primary zones. CIDRs are limited to a maximum of /24 for IPv4 and /64 for IPv6 respectively.
	// Allowed IPv4/IPv6 address range of primary or secondary nameservers. This will be applied for the entire account. The IP range is used to allow additional NOTIFY IPs for secondary zones and IPs Cloudflare allows AXFR/IXFR requests from for primary zones. CIDRs are limited to a maximum of /24 for IPv4 and /64 for IPv6 respectively.
	// +kubebuilder:validation:Optional
	IPRange *string `json:"ipRange,omitempty" tf:"ip_range,omitempty"`
}

// ZoneTransfersACLSpec defines the desired state of ZoneTransfersACL
type ZoneTransfersACLSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ZoneTransfersACLParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider ZoneTransfersACLInitParameters `json:"initProvider,omitempty"`
}

// ZoneTransfersACLStatus defines the observed state of ZoneTransfersACL.
type ZoneTransfersACLStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ZoneTransfersACLObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// ZoneTransfersACL is the Schema for the ZoneTransfersACLs API.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,cloudflare-upjet}
type ZoneTransfersACL struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.accountId) || (has(self.initProvider) && has(self.initProvider.accountId))",message="spec.forProvider.accountId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.ipRange) || (has(self.initProvider) && has(self.initProvider.ipRange))",message="spec.forProvider.ipRange is a required parameter"
	Spec   ZoneTransfersACLSpec   `json:"spec"`
	Status ZoneTransfersACLStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ZoneTransfersACLList contains a list of ZoneTransfersACLs
type ZoneTransfersACLList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ZoneTransfersACL `json:"items"`
}

// Repository type metadata.
var (
	ZoneTransfersACL_Kind             = "ZoneTransfersACL"
	ZoneTransfersACL_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ZoneTransfersACL_Kind}.String()
	ZoneTransfersACL_KindAPIVersion   = ZoneTransfersACL_Kind + "." + CRDGroupVersion.String()
	ZoneTransfersACL_GroupVersionKind = CRDGroupVersion.WithKind(ZoneTransfersACL_Kind)
)

func init() {
	SchemeBuilder.Register(&ZoneTransfersACL{}, &ZoneTransfersACLList{})
}
